/**
 * ASCII顺序排序
 * @param {*} obj 对象
 * @returns 
 */
var ascii = function ascii() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (!Object.keys(obj).length) {
    return '必须传一个对象';
  }
  var arr = new Array();
  var num = 0;
  for (var i in obj) {
    arr[num] = i;
    num++;
  }
  var sortArr = arr.sort();
  var str = ''; //自定义排序字符串
  for (var _i in sortArr) {
    str += sortArr[_i] + obj[sortArr[_i]];
  }
  return str;
};

/**
 * 字符长度
 * @param size 字符
 * @returns 
 */
var characterSize = function characterSize() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return size.toString().replace(/[\u0391-\uFFE5]/g, "aa").length;
};

/**
 * 字符长度排序
 * @param {*} arr 数组
 * @returns 
 */
var sortSize = function sortSize() {
  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return arr.sort(function (a, b) {
    return characterSize(a) - characterSize(b);
  });
};

/**
 * 排序
 * @param {*} arr 数组
 * @param {*} type asc 升序；desc 降序
 * @param {*} key 排序字段
 * @returns 
 */
var sort = function sort(_ref) {
  var _ref$arr = _ref.arr,
    arr = _ref$arr === void 0 ? [] : _ref$arr,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'asc' : _ref$type,
    _ref$key = _ref.key,
    key = _ref$key === void 0 ? '' : _ref$key;
  if (key == '') {
    if (type == 'asc') {
      // 升序
      return arr.sort(function (a, b) {
        return a - b;
      });
    } else {
      // 降序
      return arr.sort(function (a, b) {
        return b - a;
      });
    }
  } else {
    return arr.sort(function (a, b) {
      var obj1 = a[key],
        obj2 = b[key];
      var obj = obj1 - obj2;
      if (type == 'asc') {
        obj = obj1 - obj2;
      } else if (type == 'desc') {
        obj = obj2 - obj1;
      }
      return obj;
    });
  }
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/**
 * 深拷贝
 * @param {*} deep 
 * @returns 
 */
var deepClone = function deepClone(deep) {
  // 1.判断 返回的变量为 数组还是对象
  var clone = Array.isArray(deep) ? [] : {};
  // 2.判定传进来的数组是否有值和 是否为对象
  if (deep && _typeof(deep) === "object") {
    // 3.迭代数组中的每一个数值
    for (var key in deep) {
      // 4. hasOwnProperty 查找属性是都在自身身上;如果在就返回为true 否则就false  原型链不算
      if (deep.hasOwnProperty(key)) {
        // console.log(deep[key]);
        // 5.判断数据是否是对象;如果是就在调用递归函数继续执行
        if (deep[key] && _typeof(deep[key]) === 'object') {
          clone[key] = deepClone(deep[key]);
        } else {
          // 6.如果不等于对象就直接赋值返回                        
          clone[key] = deep[key];
        }
      }
    }
  }
  // 7.返回
  return clone;
};

/**
 * 防抖
 * @param {*} fn 函数 
 * @param {*} time 时间 
 * @returns 
 */

var timer = null;
var antiShake = function antiShake(foo) {
  // 如果有时间就清除
  if (timer) clearTimeout(timer);
  shake(foo);
};
var shake = function shake(_ref) {
  var fn = _ref.fn,
    _ref$time = _ref.time,
    time = _ref$time === void 0 ? 500 : _ref$time;
  var context = this;
  var ages = arguments;
  timer = setTimeout(function () {
    // 在定时器里面调用需要 防抖的函数
    fn.call(context, ages);
  }, time);
};

var index = {
  meAscii: ascii,
  meCharacterSize: characterSize,
  meSortSize: sortSize,
  meSort: sort,
  meDeepClone: deepClone,
  meAntiShake: antiShake
};

export { index as default };
