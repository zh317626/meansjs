'use strict';

/**
 * ASCII顺序排序
 * @param {*} obj 对象
 * @returns 
 */
var ascii = function ascii() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (!Object.keys(obj).length) {
    return '必须传一个对象';
  }
  var arr = new Array();
  var num = 0;
  for (var i in obj) {
    arr[num] = i;
    num++;
  }
  var sortArr = arr.sort();
  var str = ''; //自定义排序字符串
  for (var _i in sortArr) {
    str += sortArr[_i] + obj[sortArr[_i]];
  }
  return str;
};

/**
 * 字符长度
 * @param size 字符
 * @returns 
 */
var characterSize = function characterSize() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return size.toString().replace(/[\u0391-\uFFE5]/g, "aa").length;
};

/**
 * 字符长度排序
 * @param {*} arr 数组
 * @returns 
 */
var sortSize = function sortSize() {
  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return arr.sort(function (a, b) {
    return characterSize(a) - characterSize(b);
  });
};

/**
 * 排序
 * @param {*} arr 数组
 * @param {*} type asc 升序；desc 降序
 * @param {*} key 排序字段
 * @returns 
 */
var sort = function sort(_ref) {
  var _ref$arr = _ref.arr,
    arr = _ref$arr === void 0 ? [] : _ref$arr,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'asc' : _ref$type,
    _ref$key = _ref.key,
    key = _ref$key === void 0 ? '' : _ref$key;
  if (key == '') {
    if (type == 'asc') {
      // 升序
      return arr.sort(function (a, b) {
        return a - b;
      });
    } else {
      // 降序
      return arr.sort(function (a, b) {
        return b - a;
      });
    }
  } else {
    return arr.sort(function (a, b) {
      var obj1 = a[key],
        obj2 = b[key];
      var obj = obj1 - obj2;
      if (type == 'asc') {
        obj = obj1 - obj2;
      } else if (type == 'desc') {
        obj = obj2 - obj1;
      }
      return obj;
    });
  }
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/**
 * 深拷贝
 * @param {*} deep 
 * @returns 
 */
var deepClone = function deepClone(deep) {
  // 1.判断 返回的变量为 数组还是对象
  var clone = Array.isArray(deep) ? [] : {};
  // 2.判定传进来的数组是否有值和 是否为对象
  if (deep && _typeof(deep) === "object") {
    // 3.迭代数组中的每一个数值
    for (var key in deep) {
      // 4. hasOwnProperty 查找属性是都在自身身上;如果在就返回为true 否则就false  原型链不算
      if (deep.hasOwnProperty(key)) {
        // console.log(deep[key]);
        // 5.判断数据是否是对象;如果是就在调用递归函数继续执行
        if (deep[key] && _typeof(deep[key]) === 'object') {
          clone[key] = deepClone(deep[key]);
        } else {
          // 6.如果不等于对象就直接赋值返回                        
          clone[key] = deep[key];
        }
      }
    }
  }
  // 7.返回
  return clone;
};

var timer$1 = null;

/**
 * 防抖
 * @param {*} fn 函数 
 * @param {*} time 时间 
 * @returns 
 */
var antiShake = function antiShake(foo) {
  // 如果有时间就清除
  if (timer$1) clearTimeout(timer$1);
  shake(foo);
};
var shake = function shake(_ref) {
  var fn = _ref.fn,
    _ref$time = _ref.time,
    time = _ref$time === void 0 ? 500 : _ref$time;
  var context = this;
  var ages = arguments;
  timer$1 = setTimeout(function () {
    // 在定时器里面调用需要 防抖的函数
    fn.call(context, ages);
  }, time);
};

/**
 * 节流
 * @param {*} foo 
 * @returns 
 */
var timer = null;

/**
 * 节流
 * @param {*} fn 函数
 * @param {*} time 时间
 */
var throttle = function throttle(foo) {
  // timer = null;
  // 返回一个函数值
  utils(foo);
};
var utils = function utils(_ref) {
  var fn = _ref.fn,
    _ref$time = _ref.time,
    time = _ref$time === void 0 ? 500 : _ref$time;
  // 将this指向赋值   此时的 this 指向的是 实例 button
  var context = this;
  // 获取传过来的值
  var ages = arguments;
  // 清除定时器
  if (!timer) {
    // 判定timer没有数值
    // 声明一个定时器
    timer = setTimeout(function () {
      // 在定时器里面调用需要 节流的函数
      fn.call(context, ages);
      // 如果执行到这儿的是否需要把 timer 初始化 为null  ;便于下次判断
      clearTimeout(timer);
      timer = null;
    }, time);
  }
};

/**
 * 数组去重
 * @param {*} arr 数组
 * @param {*} key 默认为空,一维数组
 * @returns 
 */
var deWeight = function deWeight(arr) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var isKeyObj = arr.some(function (item) {
    return Object.keys(item).length;
  });
  if (isKeyObj && !key) throw new Error('key值不能为空');
  var map = new Map();
  var arrs = [];
  if (!key) {
    arrs = arr.filter(function (item) {
      return !map.has(item) && map.set(item);
    });
  } else if (key) {
    var isKey = arr.some(function (item) {
      return item[key];
    });
    if (!isKey) throw new Error("\u6570\u7EC4\u4E2D\u672A\u67E5\u5230".concat(key, "\u503C\uFF0C\u8BF7\u68C0\u67E5\u4FEE\u6539"));
    arrs = arr.filter(function (item) {
      return !map.has(item[key]) && map.set(item[key]);
    });
  }
  return arrs;
};

var index$1 = {
  meAscii: ascii,
  meCharacterSize: characterSize,
  meSortSize: sortSize,
  meSort: sort,
  meDeepClone: deepClone,
  meAntiShake: antiShake,
  meThrottle: throttle,
  meDeWeight: deWeight
};

function meansjs() {}
meansjs.prototype = index$1;
var index = new meansjs();

module.exports = index;
